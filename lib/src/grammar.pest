// libmagic.pest

// The main rule parses multiple lines in a magic file.
file = { SOI ~ (rule_dependency | rule | NEWLINE)* ~ EOI }

rule_dependency = { name_entry ~ NEWLINE ~ ((match_depth | use | flag) ~ (NEWLINE | EOI))+ }
name_entry      = { offset ~ "name" ~ rule_name ~ message? }

// A rule consists of an offset, type, test, and optional message or continuation
rule = { match_no_depth ~ (NEWLINE+ | EOI) ~ ((match_depth | use | flag) ~ (NEWLINE | EOI) | NEWLINE)* }

// we need the both to be able to match
match_no_depth = ${ offset ~ WHITESPACE+ ~ test ~ (WHITESPACE+ ~ message)* }
match_depth    = ${ depth+ ~ offset ~ WHITESPACE+ ~ test ~ (WHITESPACE+ ~ message)* }

test = ${ clear_test | scalar_test | default_test | string_test | indirect_test }

rule_name         = @{ (ASCII_ALPHANUMERIC | "-" | "_")+ }
endianness_switch = @{ "\\^" }
// use must be defined completely as it doesn't expect a message
use = ${ depth+ ~ offset ~ WHITESPACE+ ~ "use" ~ WHITESPACE+ ~ endianness_switch? ~ rule_name }

// operators
op_add    = ${ "+" }
op_mul    = ${ "*" }
op_sub    = ${ "-" }
op_div    = ${ "/" }
op_and    = ${ "&" }
op_mod    = ${ "%" }
op_or     = ${ "|" }
op_xor    = ${ "^" }
op_negate = ${ "!" }
op_gt     = ${ ">" }
op_eq     = ${ "=" }
op_lt     = ${ "<" }

// flags
printable_no_ws =  { '\u{21}'..'\u{7E}' }
mime_type       = @{ (ASCII_ALPHANUMERIC | "-" | "/" | ".")+ }
mime_flag       =  { "mime" ~ WHITESPACE+ ~ mime_type }
exts            = @{ printable_no_ws+ }
ext_flag        =  { "ext" ~ WHITESPACE+ ~ exts }
apple_flag      =  { "apple" ~ WHITESPACE+ ~ printable_no_ws{8} }
strength_op     = @{ op_add | op_mul | op_sub | op_div }
strength_flag   =  { "strength" ~ WHITESPACE+ ~ strength_op ~ WHITESPACE* ~ b10_number }
flag            = ${ "!:" ~ (mime_flag | ext_flag | apple_flag | strength_flag) }

neg_number = ${ "-" ~ pos_number }
// hex must be checked first as 0 is also b10 number
pos_number = ${ b16_number | b10_number }
number     =  { pos_number | neg_number }
b10_number = @{ ASCII_DIGIT+ }
b16_number = @{ "0x" ~ ASCII_HEX_DIGIT+ }

// Parses offset as an integer at the start of a rule
abs_offset = ${ number }
rel_offset = ${ "&" ~ number }

ind_offset_sign = @{ "." | "," }
ind_offset_type = @{ "b" | "c" | "B" | "C" | "e" | "f" | "g" | "E" | "F" | "G" | "h" | "s" | "H" | "S" | "i" | "I" | "l" | "L" | "m" | "o" | "q" | "Q" }
dir_shift       =  { number }
ind_shift       =  { "(" ~ number ~ ")" }
shift           =  { dir_shift | ind_shift }
indirect_offset = ${ "&"? ~ "(" ~ (abs_offset | rel_offset) ~ ind_offset_sign ~ ind_offset_type ~ ((op_add | op_sub | op_mul | op_div | op_mod | op_and | op_or | op_xor) ~ shift)? ~ ")" }

offset = ${ rel_offset | abs_offset | indirect_offset }

// all data types
bedate      = @{ "bedate" }
bedouble    = @{ "bedouble" }
befloat     = @{ "befloat" }
beldate     = @{ "beldate" }
belong      = @{ "belong" }
beqdate     = @{ "beqdate" }
bequad      = @{ "bequad" }
beshort     = @{ "beshort" }
bestring16  = @{ "bestring16" }
byte        = @{ "byte" }
der         = @{ "der" }
guid        = @{ "guid" }
ldate       = @{ "ldate" }
ledate      = @{ "ledate" }
ledouble    = @{ "ledouble" }
lefloat     = @{ "lefloat" }
leldate     = @{ "leldate" }
lelong      = @{ "lelong" }
lemsdosdate = @{ "lemsdosdate" }
lemsdostime = @{ "lemsdostime" }
leqdate     = @{ "leqdate" }
leqldate    = @{ "leqldate" }
lequad      = @{ "lequad" }
leqwdate    = @{ "leqwdate" }
leshort     = @{ "leshort" }
lestring16  = @{ "lestring16" }
long        = @{ "long" }
medate      = @{ "medate" }
melong      = @{ "melong" }
pstring_mod = @{ "B" | "H" | "h" | "L" | "l" | "J" }
pstring     =  { "pstring" ~ ("/" ~ pstring_mod)? }
quad        = @{ "quad" }
qwdate      = @{ "qwdate" }
regex_mod   = @{ "c" | "s" | "l" }
regex       =  { "regex" ~ ("/" ~ pos_number)? ~ ("/" ~ (regex_mod | string_mod)+)? }
search      =  { "search" ~ ("/" ~ pos_number)? ~ ("/" ~ string_mod+)? }
short       = @{ "short" }
string_mod  = @{ "b" | "C" | "c" | "f" | "T" | "t" | "W" | "w" }
string      =  { "string" ~ ("/" ~ pos_number)? ~ ("/" ~ string_mod+)? }
u4          = @{ "u4" }
ubelong     = @{ "ubelong" }
ubequad     = @{ "ubequad" }
ubeshort    = @{ "ubeshort" }
ubyte       = @{ "ubyte" }
uledate     = @{ "uledate" }
ulelong     = @{ "ulelong" }
ulequad     = @{ "ulequad" }
uleshort    = @{ "uleshort" }
ulong       = @{ "ulong" }
uquad       = @{ "uquad" }
ushort      = @{ "ushort" }
ustring     = @{ "ustring" }

// special keywords
default = { "default" }
clear   = { "clear" }
// current stream position
offset_ty = { "offset" }
indirect  = { "indirect" }

value_read = { "x" }

// tests on scalar data types
scalar_type      = ${ bedate | beldate | belong | beqdate | bequad | beshort | byte | leldate | lelong | ledate | leqdate | leshort | lemsdosdate | lemsdostime | long | offset | short | u4 | quad | ubelong | lequad | ubequad | ubeshort | ubyte | ulelong | ulequad | uleshort | ushort | ulong | uledate | offset_ty }
scalar_value     = ${ number }
scalar_transform = ${ (op_and | op_div | op_add | op_sub | op_mod | op_xor | op_mul) ~ pos_number }
scalar_condition = ${ op_eq | op_gt | op_lt | op_negate | op_xor | op_and }
scalar_test      = ${ scalar_type ~ scalar_transform{,1} ~ WHITESPACE+ ~ ((scalar_condition{,1} ~ scalar_value) | value_read) }

// corresponds to `clear x` test
clear_test = ${ clear ~ WHITESPACE+ ~ value_read }

// corresponds to `default x` test
default_test = ${ default ~ WHITESPACE+ ~ value_read }

indirect_test = ${ indirect ~ WHITESPACE+ ~ value_read }

// string test
string_value = ${ (!(WHITESPACE | NEWLINE) ~ ("\\ " | ANY))+ }
string_test  = ${ (string | pstring | regex | search) ~ WHITESPACE+ ~ "="? ~ (value_read | string_value) }

// Test value (could be a hex, string, or integer)
// test = ${ (b16_number ~ ASCII_DIGIT* | (PUNCTUATION | ASCII_ALPHANUMERIC | ("\\x" ~ ASCII_HEX_DIGIT{2}))+) | "x" }

// Parses the optional message that describes the file type
message = @{ (!NEWLINE ~ ANY)* }

depth = @{ ">"+ }

// Parses comments
// see pest doc to define COMMENT
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }

// Special characters
NEWLINE = _{ "\n" | "\r\n" }
// "\ " must not be treated as a whitespace as it is the
// way to encode spaces into string/regex match
WHITESPACE = _{ !("\\ ") ~ (" " | "\t") }
